# 9章クラス：ジェネレータ式（generator expression）
# リスト内包と同様の構文で丸カッコ()を使い、ジェネレータオブジェクトを返す
# 注意！：ジェネレータ式は yield next() で中身を消費しながら処理するため、1回使い切り型のイテレータなのだ！（ΩΩΩ＜な、なんだってーーー！？）

# ジェネレータ式からジェネレータオブジェクトを生成
gen = (i*i for i in range(5))
print(gen)

# ジェネレータオブジェクトからリストに変換できる
# listへの変換でジェネレータオブジェクトの中身が全部消費されて空になる！
li = list(gen)
print(li)

# なので、次にnext()すると例外になる
try:
    next(gen)
except Exception as e:
    print("例外：", type(e), e)

# もう一度、ジェネレータ式からジェネレータオブジェクトを生成
gen = (i*2 for i in range(5))
print(gen)

# ジェネレータオブジェクトのままforで回せる：つまりジェネレータオブジェクトは反復可能体（イテラブル）
# 補足：ジェネレータオブジェクトは反復可能体（イテラブル）かつ反復子（イテレータ）：__next__()で次を取り出せるものが反復子（イテレータ）
for i in gen:
    print(i)

# ちなみに、リストやタプルは反復可能体（イテラブル）だが反復子（イテレータ）ではない
# __iter__()でイテレータを取得できるが、__next__()が無いため次を取得できない
# チノ(ChatGPT)がこれも追加しろって言うから書いた（おい
