# 問題集4章：問題3.
# is演算子

# ==演算子は2つのオブジェクトの値が等価（同値）かを比較・判定し、
# is演算子は2つのオブジェクトが同一かを比較・判定する

a = 100
b = 100

print(f"a = {a}, b = {b}")
print(f"a == b: {a == b}")
# 出力：True

# is演算子による同一性チェック（同じオブジェクトか？）
print(f"a is b: {a is b}")
# 出力：True
# Python では、よく使う整数は最初から作って使い回す仕組みがある
# デフォルトでは -5～256 の整数はシングルトン扱いでキャッシュされる

# つまり直値「100」はシングルトンで同じオブジェクトになる！
# a と b のid値を確認すると同じ！
print(f"id(a) = {id(a)}\nid(b) = {id(b)}")
# id(a) = 140726463451144
# id(b) = 140726463451144

# シングルトン扱いでキャッシュされてる範囲から外れる値で同一性チェック！
a = 1234
b = 1234
print(f"a = {a}, b = {b}")
print(f"a is b: {a is b}")
# 出力：True
# おい！なんでだよ！責任者でてこい！モンティパイソンでてこい！

# なんでか？
# Python は起動時によく使うオブジェクトをキャッシュして再利用する
# 整数は通常 -5〜256 だけが保証されたキャッシュ範囲
# だけど、ソースコード上に同じリテラルが2回出ると最適化で同じオブジェクトを使うことがある
# 今回、両方の 1234 が同じコードブロック内で登場したため、
# Python が最適化で 同じオブジェクトを再利用 して is True になった

# マジで！？
# クッソめんどくさいけど仕方ないので id() で確認
print(f"id(a) = {id(a)}\nid(b) = {id(b)}")
# id(a) = 2218828805712
# id(b) = 2218828805712
# →マジだった

# じゃあこれでどうじゃ！
a = 12345
b = int("12345")

print(f"a = {a}, b = {b}")
print(f"a == b: {a == b}")
# 出力：True
print(f"a is b: {a is b}")
# 出力：False

# id()　の確認
print(f"id(a) = {id(a)}\nid(b) = {id(b)}")
# id(a) = 2945626266512
# id(b) = 2945626266704
# ちがうオブジェクトなので is演算子で False となる（やっと出た…）

##### おまけ #####

# 同値だけど別オブジェクトにする別パターンの実験：関数をはさむ
# 関数をはさんで、かつ、計算式にしたら別オブジェクトになるよね？ね？（フラグ）
def get_number():
    return 123000 + 456

a = 123456
b = get_number()

print(f"a is b: {a is b}")
# 出力：True
print(f"id(a) = {id(a)}\nid(b) = {id(b)}")
# id(a) = 1890471763088
# id(b) = 1890471763088
# ここまでやっても同じオブジェクトになるやつーーーーー！！！
# Pythonって最適化すごいね！（終）

##### おまけ2 #####

a = "kotone"
b = "kotone"

print(f"a = {a}, b = {b}")
print(f"a == b: {a == b}")
# 出力：True
print(f"a is b: {a is b}")
# 出力：True
# 文字列リテラルも最適化で同一オブジェクトになる

a = [1, 2, 3]
b = [1, 2, 3]

print(f"a = {a}, b = {b}")
print(f"a == b: {a == b}")
# 出力：True
print(f"a is b: {a is b}")
# 出力：False
# ミュータブル（可変体）オブジェクトのリストだと確実に同値・別オブジェクトを確認できる
# 最初からこうしておけばよかった…
